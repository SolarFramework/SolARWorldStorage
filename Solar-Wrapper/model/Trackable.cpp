/**
* World Storage API
* API ensuring interoperability between an authoring tool and a World Storage service
*
* The version of the OpenAPI document: 0.0.1
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "Trackable.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

Trackable::Trackable()
{
    m_CreatorUID = "";
    m_Trackabletype = "";
    m_Unitsystem = "";
    m_KeyvalueTagListIsSet = false;
    
}

void Trackable::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool Trackable::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool Trackable::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "Trackable" : pathPrefix;

                     
    
    /* Payload */ {
        const std::vector<std::string>& value = m_Payload;
        const std::string currentValuePath = _pathPrefix + ".payload";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const std::string& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
 
                i++;
            }
        }

    }
             
    
    /* TrackableDimension */ {
        const std::vector<int32_t>& value = m_TrackableDimension;
        const std::string currentValuePath = _pathPrefix + ".trackableDimension";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const int32_t& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
 
                i++;
            }
        }

    }
            
    return success;
}

bool Trackable::operator==(const Trackable& rhs) const
{
    return
    
    
    (getCreatorUID() == rhs.getCreatorUID())
     &&
    
    (getTrackabletype() == rhs.getTrackabletype())
     &&
    
    (getTrackableEncodingInformation() == rhs.getTrackableEncodingInformation())
     &&
    
    (getPayload() == rhs.getPayload())
     &&
    
    (getUnitsystem() == rhs.getUnitsystem())
     &&
    
    (getTrackableDimension() == rhs.getTrackableDimension())
     &&
    
    (getLocalcrs() == rhs.getLocalcrs())
     &&
    
    
    ((!keyvalueTagListIsSet() && !rhs.keyvalueTagListIsSet()) || (keyvalueTagListIsSet() && rhs.keyvalueTagListIsSet() && getKeyvalueTagList() == rhs.getKeyvalueTagList()))
    
    ;
}

bool Trackable::operator!=(const Trackable& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const Trackable& o)
{
    j = nlohmann::json();
    j["creatorUID"] = o.m_CreatorUID;
    j["trackabletype"] = o.m_Trackabletype;
    j["trackableEncodingInformation"] = o.m_TrackableEncodingInformation;
    j["payload"] = o.m_Payload;
    j["unitsystem"] = o.m_Unitsystem;
    j["trackableDimension"] = o.m_TrackableDimension;
    j["localcrs"] = o.m_Localcrs;
    if(o.keyvalueTagListIsSet() || !o.m_KeyvalueTagList.empty())
        j["keyvalueTagList"] = o.m_KeyvalueTagList;
    
}

void from_json(const nlohmann::json& j, Trackable& o)
{
    j.at("creatorUID").get_to(o.m_CreatorUID);
    j.at("trackabletype").get_to(o.m_Trackabletype);
    j.at("trackableEncodingInformation").get_to(o.m_TrackableEncodingInformation);
    j.at("payload").get_to(o.m_Payload);
    j.at("unitsystem").get_to(o.m_Unitsystem);
    j.at("trackableDimension").get_to(o.m_TrackableDimension);
    j.at("localcrs").get_to(o.m_Localcrs);
    if(j.find("keyvalueTagList") != j.end())
    {
        j.at("keyvalueTagList").get_to(o.m_KeyvalueTagList);
        o.m_KeyvalueTagListIsSet = true;
    } 
    
}

std::string Trackable::getCreatorUID() const
{
    return m_CreatorUID;
}
void Trackable::setCreatorUID(std::string const& value)
{
    m_CreatorUID = value;
}
std::string Trackable::getTrackabletype() const
{
    return m_Trackabletype;
}
void Trackable::setTrackabletype(std::string const& value)
{
    m_Trackabletype = value;
}
TrackableEncodingInformationStructure Trackable::getTrackableEncodingInformation() const
{
    return m_TrackableEncodingInformation;
}
void Trackable::setTrackableEncodingInformation(TrackableEncodingInformationStructure const& value)
{
    m_TrackableEncodingInformation = value;
}
std::vector<std::string> Trackable::getPayload() const
{
    return m_Payload;
}
void Trackable::setPayload(std::vector<std::string> const& value)
{
    m_Payload = value;
}
std::string Trackable::getUnitsystem() const
{
    return m_Unitsystem;
}
void Trackable::setUnitsystem(std::string const& value)
{
    m_Unitsystem = value;
}
std::vector<int32_t> Trackable::getTrackableDimension() const
{
    return m_TrackableDimension;
}
void Trackable::setTrackableDimension(std::vector<int32_t> const value)
{
    m_TrackableDimension = value;
}
Transform3d Trackable::getLocalcrs() const
{
    return m_Localcrs;
}
void Trackable::setLocalcrs(Transform3d const& value)
{
    m_Localcrs = value;
}
std::map<std::string, std::string> Trackable::getKeyvalueTagList() const
{
    return m_KeyvalueTagList;
}
void Trackable::setKeyvalueTagList(std::map<std::string, std::string> const& value)
{
    m_KeyvalueTagList = value;
    m_KeyvalueTagListIsSet = true;
}
bool Trackable::keyvalueTagListIsSet() const
{
    return m_KeyvalueTagListIsSet;
}
void Trackable::unsetKeyvalueTagList()
{
    m_KeyvalueTagListIsSet = false;
}


} // namespace org::openapitools::server::model

